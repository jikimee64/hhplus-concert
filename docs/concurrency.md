## 동시성 시나리오 분석

### 유저 잔액 충전

#### 정상 시나리오
![img.png](images/img.png)  

####  동시성으로 인한 문제 발생 시나리오
![img.png](images/img2.png)

#### 비즈니스 로직 순서

```text
tx {
  - 유저 조회
  - 잔액 업데이트
}
```

- 전체 비즈니스 로직을 트랜잭션으로 묶는다.
    - 조회 후 갱신이기 때문에 동시성 문제가 발생할 수 있다.
    - 동시성 문제가 발생하면 잔액 충전의 요청이 정합성이 깨질 수 있다.

#### 락 적용
- 비관적 락 적용

#### 낙관적 락 선택 이유
- 유저의 잔액 충전은 본인만 가능하다. 그렇기 때문에 동시성으로 인한 문제가 발생할 가능성은 낮다.
- 유저의 잔액 충전은 공정성이 필요하지 않기 때문에 낙관적 락 적용시 문제 없다.
- 잔액 충전에 락을 적용하는 이유는 따닥을 막기 위함이다.
  - 잔액 충전을 한번만 성공시켜야 한다. 
- 비즈니스 흐름과 로직의 복잡도가 간단하기 때문에 비관적 락을 선택해도 문제는 없지만 커넥션 낭비를 조금이라도 줄이기 위해 낙관적 락을 선택 했다. 

#### 낙관적 락 주의 사항
- 요청이 많은데 리트라이 재시도 횟수가 적을 경우 데이터 정합성이 깨질 수 있다.
    - 지정한 횟수 까지 재시도를 했어도 마지막 까지 실패한 요청같은 경우는 업데이트가 반영이 되지 않기 때문이다.
    - 테스트를 해보면서 적절한 리트라이 횟수를 찾아야 한다.
- 재시도 횟수가 많을 수록 디비 부하가 걸리기 때문에 해당 메서드 자체의 실행 속도는 비관적 락 보다 오히려 증가할 수 있다. 

#### 비관적 락과 낙관적 락 실행 속도 비교
- 스레드 수를 점진적으로 늘려 가면서 테스트 코드 실행 시간 비교

| 스레드 수            | 낙관적 락  | 비관적 락 |
|------------------|--------|-------|
| 스레드 10개시 수행 속도   | 0.7s   | 0.8s  |
| 스레드 100개시 수행 속도  | 1.2s   | 0.6s  |
| 스레드 1000개시 수행 속도 | 7.251s | 2.4s  |
- 낙관적 락의 경우 스레드 요청수를 증가시킬 수록 적절한 재시도 횟수를 찾아야 데이터 정합성을 유지할 수 있다.
- 스레드 요청이 많을 경우 낙관적 락의 수행 속도가 더 오래 걸리는 결과가 나왔다.
