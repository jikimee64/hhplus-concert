## 트랜잭션 및 이벤트 설계 보고서

- API 중 이벤트를 적용에 적합한 결제 API의 트랜잭션 분석 및 이벤트에 대한 설계를 진행한다.

### 결제 API

#### 기존 트랜잭션 범위

```text
(트랜잭션 시작)
- 예약 정보 조회
- 예약 금액과 유저 보유 금액 비교
- 유저 보유 금액 차감
- 예약 상태 변경
- 전체 좌석 마감시 콘서트 스케줄 좌석 만료 업데이트
- 결제 정보 저장
- 대기열 활성화 토큰 삭제
(트랜잭션 끝)
```

- 대기열 활성화 토큰 삭제는 결제 API의 메인 기능이 아니므로 이벤트로 분리하기에 적합하다
    - 대기열 활성화 토큰 삭제가 실패해도 결제예는 영향을 미치면 안된다.
    - 나머지 로직은 결제 유스케이스의 한 묶음으로 처리한다.

#### 기존 트랜잭션 범위

```text
(트랜잭션 시작)
- 예약 정보 조회
- 예약 금액과 유저 보유 금액 비교
- 유저 보유 금액 차감
- 예약 상태 변경
- 전체 좌석 마감시 콘서트 스케줄 좌석 만료 업데이트
- 결제 정보 저장
(트랜잭션 끝)
- 결제 완료 이벤트 발생
  - 대기열 활성화 토큰 삭제
  - 결제 및 예약 정보 전달
```

- 결제 완료 이벤트는 이벤트 호출한 메서드의 트랜잭션이 끝난 후 호출되며, 비동기로 실행 된다.
- 서비스 분리
    - 대기열 활성화 토큰 삭제는 '대기열 토큰 서버', 결제 및 예약 정보 전달은 '통계 서버' 혹은 타 부서의 '서버'로 볼 수 있다.
    - 이벤트 리스너 내에서 'API 호출'과 '메시지 큐'를 사용하는 방법이 있다.
        - API 호출은 target 서버의 로직에서 실패가 발생하면 target 서버가 source 서버로 API 호출을 다시 하거나 source 서버에서 재시도 로직을 적용해야 하는데 결합도와 복잡성이 올라간다.
        - 메시지 큐는 target 서버가 실패하더라도 큐에서 데이터를 다시 컨슘해가면 되기 때문에 producer 서버는 성공적으로 처리한 것으로 간주할 수 있다.

- 결제 완료 이벤트 구현체들이 실패하면?
    - 해당 로직들은 결제 유스케이스와는 다른 책임의 로직이기 때문에 실패해도 결제 유스케이스에 영향을 미치면 안된다.
    - 대기열 활성화 토큰 삭제는 레디스를 호출한다. 결제 및 예약 정보 전달은 API 혹은 카프카를 호출한다고 가정하자.
        - 둘다 외부 네트워크를 호출하기 때문에 실패시 1번의 재시도 로직을 시도해준다.
 